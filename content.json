[{"title":"MongoDB基本命令","date":"2017-04-05T01:54:24.000Z","path":"2017/04/05/mongoDB/MongoDB基本命令/","text":"MONGODB基本命令用成功启动MongoDB后，再打开一个命令行窗口输入mongo，就可以进行数据库的一些操作。 输入help可以看到基本操作命令： show dbs:显示数据库列表show collections：显示当前数据库中的集合（类似关系数据库中的表）show users：显示用户 use ：切换当前数据库，这和MS-SQL里面的意思一样db.help()：显示数据库操作命令，里面有很多的命令db.foo.help()：显示集合操作命令，同样有很多的命令，foo指的是当前数据库下，一个叫foo的集合，并非真正意义上的命令db.foo.find()：对于当前数据库中的foo集合进行数据查找（由于没有条件，会列出所有数据）db.foo.find( { a : 1 } )：对于当前数据库中的foo集合进行查找，条件是数据中有一个属性叫a，且a的值为1 MongoDB没有创建数据库的命令，但有类似的命令。 如：如果你想创建一个“myTest”的数据库，先运行use myTest命令，之后就做一些操作（如：db.createCollection(‘user’)）,这样就可以创建一个名叫“myTest”的数据库。 数据库常用命令 1、Help查看命令提示 help db.help(); db.yourColl.help(); db.youColl.find().help(); rs.help(); 2、切换/创建数据库 use yourDB; 当创建一个集合(table)的时候会自动创建当前数据库 3、查询所有数据库 show dbs; 4、删除当前使用数据库 db.dropDatabase(); 5、从指定主机上克隆数据库 db.cloneDatabase(“127.0.0.1”); 将指定机器上的数据库的数据克隆到当前数据库 6、从指定的机器上复制指定数据库数据到某个数据库 db.copyDatabase(“mydb”, “temp”, “127.0.0.1”);将本机的mydb的数据复制到temp数据库中 7、修复当前数据库 db.repairDatabase(); 8、查看当前使用的数据库 db.getName(); db; db和getName方法是一样的效果，都可以查询当前使用的数据库 9、显示当前db状态 db.stats(); 10、当前db版本 db.version(); 11、查看当前db的链接机器地址 db.getMongo(); Collection聚集集合 1、创建一个聚集集合（table） db.createCollection(“collName”, {size: 20, capped: 5, max: 100}); 2、得到指定名称的聚集集合（table） db.getCollection(“account”); 3、得到当前db的所有聚集集合 db.getCollectionNames(); 4、显示当前db所有聚集索引的状态 db.printCollectionStats(); 用户相关 1、添加一个用户 db.addUser(“name”); db.addUser(“userName”, “pwd123”, true); 添加用户、设置密码、是否只读 2、数据库认证、安全模式 db.auth(“userName”, “123123”); 3、显示当前所有用户 show users; 4、删除用户 db.removeUser(“userName”); 其他 1、查询之前的错误信息 db.getPrevError(); 2、清除错误记录 db.resetError(); 查看聚集集合基本信息 1、查看帮助 db.yourColl.help(); 2、查询当前集合的数据条数 db.yourColl.count(); 3、查看数据空间大小 db.userInfo.dataSize(); 4、得到当前聚集集合所在的db db.userInfo.getDB(); 5、得到当前聚集的状态 db.userInfo.stats(); 6、得到聚集集合总大小 db.userInfo.totalSize(); 7、聚集集合储存空间大小 db.userInfo.storageSize(); 8、Shard版本信息 db.userInfo.getShardVersion() 9、聚集集合重命名 db.userInfo.renameCollection(“users”); 将userInfo重命名为users 10、删除当前聚集集合 db.userInfo.drop(); 聚集集合查询 1、查询所有记录 db.userInfo.find(); 相当于：select* from userInfo; 默认每页显示20条记录，当显示不下的情况下，可以用it迭代命令查询下一页数据。注意：键入it命令不能带“；” 但是你可以设置每页显示数据的大小，用DBQuery.shellBatchSize= 50;这样每页就显示50条记录了。 2、查询去掉后的当前聚集集合中的某列的重复数据 db.userInfo.distinct(“name”); 会过滤掉name中的相同数据 相当于：select distict name from userInfo; 3、查询age = 22的记录 db.userInfo.find({“age”: 22}); 相当于： select * from userInfo where age = 22; 4、查询age &gt; 22的记录 db.userInfo.find({age: {$gt: 22}}); 相当于：select * from userInfo where age &gt;22; 5、查询age &lt; 22的记录 db.userInfo.find({age: {$lt: 22}}); 相当于：select * from userInfo where age &lt;22; 6、查询age &gt;= 25的记录 db.userInfo.find({age: {$gte: 25}}); 相当于：select * from userInfo where age &gt;= 25; 7、查询age &lt;= 25的记录 db.userInfo.find({age: {$lte: 25}}); 8、查询age &gt;= 23 并且 age &lt;= 26 db.userInfo.find({age: {$gte: 23, $lte: 26}}); 9、查询name中包含 mongo的数据 db.userInfo.find({name: /mongo/}); //相当于%% select * from userInfo where name like ‘%mongo%’; 10、查询name中以mongo开头的 db.userInfo.find({name: /^mongo/}); select * from userInfo where name like ‘mongo%’; 11、查询指定列name、age数据 db.userInfo.find({}, {name: 1, age: 1}); 相当于：select name, age from userInfo; 当然name也可以用true或false,当用ture的情况下河name:1效果一样，如果用false就是排除name，显示name以外的列信息。 12、查询指定列name、age数据, age &gt; 25 db.userInfo.find({age: {$gt: 25}}, {name: 1, age: 1}); 相当于：select name, age from userInfo where age &gt;25; 13、按照年龄排序 升序：db.userInfo.find().sort({age: 1}); 降序：db.userInfo.find().sort({age: -1}); 14、查询name = zhangsan, age = 22的数据 db.userInfo.find({name: ‘zhangsan’, age: 22}); 相当于：select * from userInfo where name = ‘zhangsan’ and age = ‘22’; 15、查询前5条数据 db.userInfo.find().limit(5); 相当于：selecttop 5 * from userInfo; 16、查询10条以后的数据 db.userInfo.find().skip(10); 相当于：select * from userInfo where id not in ( selecttop 10 * from userInfo ); 17、查询在5-10之间的数据 db.userInfo.find().limit(10).skip(5); 可用于分页，limit是pageSize，skip是第几页*pageSize 18、or与 查询 db.userInfo.find({$or: [{age: 22}, {age: 25}]}); 相当于：select * from userInfo where age = 22 or age = 25; 19、查询第一条数据 db.userInfo.findOne(); 相当于：selecttop 1 * from userInfo; db.userInfo.find().limit(1); 20、查询某个结果集的记录条数 db.userInfo.find({age: {$gte: 25}}).count(); 相当于：select count(*) from userInfo where age &gt;= 20; 如果要返回限制之后的记录数量，要使用count(true)或者count(非0)db.users.find().skip(10).limit(5).count(true); 21、按照某列进行排序 db.userInfo.find({sex: {$exists: true}}).count(); 相当于：select count(sex) from userInfo; 索引 1、创建索引 db.userInfo.ensureIndex({name: 1}); db.userInfo.ensureIndex({name: 1, ts: -1}); 2、查询当前聚集集合所有索引 db.userInfo.getIndexes(); 3、查看总索引记录大小 db.userInfo.totalIndexSize(); 4、读取当前集合的所有index信息 db.users.reIndex(); 5、删除指定索引 db.users.dropIndex(“name_1”); 6、删除所有索引索引 db.users.dropIndexes(); 修改、添加、删除集合数据 1、添加 db.users.save({name: ‘zhangsan’, age: 25, sex: true}); 添加的数据的数据列，没有固定，根据添加的数据为准 2、修改 db.collection.update(criteria, objNew, upsert, multi ) criteria:update的查询条件，类似sql update查询内where后面的 objNew:update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的。 upsert : 如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。 multi : mongodb默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 db.users.update({age: 25}, {$set: {name: ‘changeName’}}, false, true); 相当于：update users set name = ‘changeName’ where age = 25; db.users.update({name: ‘Lisi’}, {$inc: {age: 50}}, false, true); 相当于：update users set age = age + 50 where name = ‘Lisi’; db.users.update({name: ‘Lisi’}, {$inc: {age: 50}, $set: {name: ‘hoho’}}, false, true); 相当于：update users set age = age + 50, name = ‘hoho’ where name = ‘Lisi’; 3、删除 db.users.remove({age: 132}); 4、查询修改删除 db.users.findAndModify({ query: {age: {$gte: 25}}, sort: {age: -1}, update: {$set: {name: 'a2'}, $inc: {age: 2}}, remove: true }); db.runCommand({ findandmodify : \"users\", query: {age: {$gte: 25}}, sort: {age: -1}, update: {$set: {name: 'a2'}, $inc: {age: 2}}, remove: true });","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"},{"name":"NOSQL","slug":"NOSQL","permalink":"http://yoursite.com/tags/NOSQL/"}]},{"title":"elasticsearch安装IK分词","date":"2017-04-01T10:35:24.000Z","path":"2017/04/01/elasticsearch/elasicsearch安装IK分词/","text":"ES安装IK分词，查看了网上很多人写的方案，可能由于是版本的问题，并没有安装成功，期间出现了很多的问题，自己终于摸索出来，记录下安装步骤：1、到github网站下载源代码，网站地址为：https://github.com/medcl/elasticsearch-analysis-ik/releases 里面有IK分词历史版本，根据自己ES版本进行选择下载第一个ZIP解压之后是maven编译好的，第二个需要自己手动编译 执行maven命令 mvn pageage2.讲编译好的文件解压在es\\plugins\\ik目录下。3.从新启动es服务就可以了。 注：IK分词可以在IKAnalyzer.cfg.xml文件中扩展所需要的分词字典。 总结：网上很多都有写需要在在ES的配置文件config/elasticsearch.yml中增加ik的配置，其实是完全不需要的，如果需要可能是版本比较底，经过本人测试，在2.0.0之后的版本完全不需要多余的配置。","tags":[{"name":"ES","slug":"ES","permalink":"http://yoursite.com/tags/ES/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://yoursite.com/tags/elasticsearch/"}]},{"title":"MongoDB第四篇 -- 索引操作","date":"2017-03-30T06:01:16.000Z","path":"2017/03/30/mongoDB/MongoDB第四篇/","text":"mongodb中关于索引的基本操作，首先插入10w数据一：性能分析函数（explain） 好了，数据已经插入成功，既然我们要做分析，肯定要有分析的工具，幸好mongodb中给我们提供了一个关键字叫做“explain”，那么怎么用呢？还是看图，注意，这里的name字段没有建立任何索引，这里我就查询一个“name10000”的姓名。cursor: 这里出现的是”BasicCursor”,什么意思呢，就是说这里的查找采用的是“表扫描”，也就是顺序查找。nscanned: 这里是10w，也就是说数据库浏览了10w个文档。n:这里是1，也就是最终返回了1个文档。millis:总共耗时114毫秒。 二：建立索引（ensureIndex） 这里我们使用了ensureIndex在name上建立了索引。”1“：表示按照name进行升序，”-1“：表示按照name进行降序。 cursor: 这里出现的是”BtreeCursor”，mongodb采用B树的结构来存放索引，索引名为后面的“name_1”。 nscanned: 数据库只浏览了一个文档就OK了。 n:返回文档个数。 millis: 返回时间。 三：唯一索引 和sql一样都可以建立唯一索引，重复的键值自然就不能插入，在mongodb中的使用方法是：db.person.ensureIndex({“name”:1},{“unique”:true})。 四：组合索引 有时候我们的查询不是单条件的，可能是多条件，比如查找出生在‘1989-3-2’名字叫‘jack’的同学，那么我们可以建立“姓名”和”生日“的联合索引来加速查询。看到上图，大家或者也知道name跟birthday的不同，建立的索引也不同，升序和降序的顺序不同都会产生不同的索引,那么我们可以用getindexes来查看下person集合中到底生成了那些索引。到底MongoDB查询优化器会使用哪个查询作为操作:看完上图我们要相信查询优化器，它给我们做出的选择往往是最优的，因为做查询时，查询优化器会使用我们建立的这些索引来创建查询方案，如果某一个先执行完则其他查询方案被close掉，这种方案会被mongodb保存起来，当然如果非要用自己指定的查询方案，这也是可以的，在mongodb中给我们提供了hint方法可以暴力执行。 五： 删除索引 可能随着业务需求的变化，原先建立的索引可能没有存在的必要了，可能有的人想说没必要就没必要呗，但是请记住，索引会降低CUD这三种操作的性能，因为这玩意需要实时维护，所以啥问题都要综合考虑一下，这里就把刚才建立的索引清空掉来演示一下:dropIndexes的使用。","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"},{"name":"NOSQL","slug":"NOSQL","permalink":"http://yoursite.com/tags/NOSQL/"}]},{"title":"MongoDB第三篇 -- 细说高级操作","date":"2017-03-30T03:41:46.000Z","path":"2017/03/30/mongoDB/MongoDB第三篇/","text":"一、聚合操作常见的聚合操作跟sql一样，有：count，distinct，group，mapReduce,sort,limit. count count是最简单，最容易，也是最常用的聚合工具，它的使用跟我们C#里面的count使用简直一模一样。 distinct 指定了谁，谁就不能重复 group下面举的例子就是按照age进行group操作，value为对应age的姓名。下面对这些参数介绍一下：key： 这个就是分组的key，我们这里是对年龄分组。initial: 每组都分享一个”初始化函数“，特别注意：是每一组，比如这个的age=20的value的list分享一个initial函数，age=22同样也分享一个initial函数。$reduce: 这个函数的第一个参数是当前的文档对象，第二个参数是上一次function操作的累计对象，第一次为initial中的{”perosn“：[]}。有多少个文档， $reduce就会调用多少次。我们通过age查看到了相应的name人员，不过有时我们可能有如下的要求：①：想过滤掉age&gt;25一些人员。②：有时person数组里面的人员太多，我想加上一个count属性标明一下。针对上面的需求，在group里面还是很好办到的，因为group有这么两个可选参数: condition 和 finalize。condition: 这个就是过滤条件。finalize:这是个函数，每一组文档执行完后，多会触发此方法，那么在每组集合里面加上count也就是它的活了。 mapReducemapReduce其实是一种编程模型，用在分布式计算中，其中有一个“map”函数，一个”reduce“函数。① map：这个称为映射函数，里面会调用emit(key,value)，集合会按照你指定的key进行映射分组。② reduce：这个称为简化函数，会对map分组后的数据进行分组简化，注意：在reduce(key,value)中的key就是emit中的key，vlaue为emit分组后的emit(value)的集合，这里也就是很多{“count”:1}的数组。③ mapReduce:这个就是最后执行的函数了，参数为map，reduce和一些可选参数。具体看图可知：result: “存放的集合名“；input:传入文档的个数。emit：此函数被调用的次数。reduce：此函数被调用的次数。output:最后返回文档的个数。 分页，排序var single=db.person.find().sort({“name”,1}).skip(2).limit(2);","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"},{"name":"NOSQL","slug":"NOSQL","permalink":"http://yoursite.com/tags/NOSQL/"}]},{"title":"MongoDB第二篇 -- 细说增删改查","date":"2017-03-30T03:00:46.000Z","path":"2017/03/30/mongoDB/MongoDB第二篇/","text":"一、Insert操作上一篇也说过,文档是采用“K-V”格式存储的，如果大家对JSON比较熟悉的话，我相信学mongodb是手到擒来，我们知道JSON里面Value可能是“字符串”，可能是“数组”，又有可能是内嵌的一个JSON对象，相同的方式也适合于BSON。常见的插入操作也就两种形式存在：“单条插入”和“批量插入”。① 单条插入先前也说了，mongo命令打开的是一个javascript shell。所以js的语法在这里面都行得通。② 批量插入这玩意跟“单条插入”的差异相信大家应该知道，由于mongodb中没有提供给shell的“批量插入方法”，没关系，各个语言的driver都打通了跟mongodb内部的批量插入方法，因为该方法是不可或缺的，如果非要模拟下批量插入的话，可以自己写了for循环，里面就是insert。 二、Find操作 日常开发中，做查询，用的最多的也就是二类：①： &gt;, &gt;=, &lt;, &lt;=, !=, = “$gt”, “$gte”, “$lt”, “$lte”, “$ne”, “没有特殊关键字”，这些跟上面是一一对应的。②：And，OR，In，NotIn “无关键字“, “$or”, “$in”，”$nin” 在mongodb中正则表达式的使用。 mongodb中也可以使用where条件。 三、Update操作 更新操作无非也就两种，整体更新和局部更新，使用场合相信大家也清楚。 整体更新,上一篇使用update的时候，其实那种update是属于整体更新。 局部更新有时候我们仅仅需要更新一个字段，而不是整体更新,mongodb中已经给我们提供了两个修改器： $inc 和 $set。① $inc修改器$inc也就是increase的缩写,比如我们做一个在线用户状态记录，每次修改会在原有的基础上自增$inc指定的值，如果“文档”中没有此key，则会创建key。② $set修改器 upsert操作这个可是mongodb创造出来的“词”,那么这个upsert操作就是说：如果我没有查到，我就在数据库里面新增一条，其实这样也有好处，就是避免了我在数据库里面判断是update还是add操作，使用起来很简单将update的第三个参数设为true即可。","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"},{"name":"NOSQL","slug":"NOSQL","permalink":"http://yoursite.com/tags/NOSQL/"}]},{"title":"MongoDB如何创建用户","date":"2017-03-30T01:40:24.000Z","path":"2017/03/30/mongoDB/MongoDB如何创建用户3.X以上版本/","text":"MongoDB3.0+的权限，网上搜出来的解决方法都是3.0以下的版本的，所以不适合3.0+以上的版本，由于这版本改变的有些大，解决了很久，终于解决，下面把解决的步骤记录下来。一、不使用 –auth1.首先，不使用–auth参数启动MongoDB 访问到MongoDB服务bin路径下 cd F:\\mongodb\\bin启动mongodb服务cd F:\\mongodb\\bin&gt;mongod –dbpath=F:\\mongodb\\db2.服务启动之后打开新窗口，在命令窗口输入： show dbs看到只有一个local数据库，admin是不存在的(这是3.0以上版本改变了的)，我们需要自己给他创建个admin数据库。3.添加管理用户 use admindb.createUser( { user: “admin”,pwd: “admin”, roles: [ { role: “userAdminAnyDatabase”, db: “admin” } ] })roles 中的 db 参数是必须的，不然会报错：Error: couldn’t add user: Missing expected field “db”。另外，有很多文章记录的是使用 db.addUser(…) 方法，这个方法是旧版的，3.0中已经不存在。详细：https://docs.mongodb.com/manual/reference/method/js-user-management/4.切换到admin下，查看刚才创建的用户： show users或db.system.users.find()关闭mongo，可以window+c键关闭二、使用 –auth1.再次打开mongo shell： use admindb.auth(“nieht”,”123456”) #认证，返回1表示成功2.查看整个mongoDB全部的用户： use admindb.system.users.find()3.创建完成，验证一下 use adminshow collections完成~！","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"},{"name":"NOSQL","slug":"NOSQL","permalink":"http://yoursite.com/tags/NOSQL/"}]},{"title":"MongoDB如何创建用户","date":"2017-03-30T01:40:24.000Z","path":"2017/03/30/mongoDB/MongoDB如何创建用户/","text":"一、如何创建用户管理员用户管理员是第一个要创建的用户。在没有创建任何用户之前，你可以随意创建用户；但数据库中一旦有了用户，那么未登录的客户端就没有权限做任何操作了，除非使用db.auth(username, password)方法登录。 用户管理员的角色名叫 userAdminAnyDatabase，这个角色只能在 admin 数据库中创建。下面是一个例子： |&gt; use adminswitched to db admin|&gt; db.createUser({user:”root”,pwd:”root123”,roles:[“userAdminAnyDatabase”]})Successfully added user: { “user” : “root”, “roles” : [ “userAdminAnyDatabase” ] } 这个例子创建了一个名为 root 的用户管理员。创建完了这个用户之后，我们应该马上以该用户的身份登录： |&gt; db.auth(“root”,”root123”)1db.auth() 方法返回 1 表示登录成功。接下来我们为指定的数据库创建访问所需的账号。 二、如何创建数据库用户 首先保证你已经以用户管理员的身份登录 admin 数据库。然后用 use 命令切换到目标数据库，同样用 db.createUser() 命令来创建用户，其中角色名为 “readWrite”。 普通的数据库用户角色有两种，read 和 readWrite。顾名思义，前者只能读取数据不能修改，后者可以读取和修改。下面是一个例子： |&gt; use testswitched to db test|&gt; db.createUser({user:”testuser”,pwd:”testpass”,roles:[“readWrite”]})Successfully added user: { “user” : “testuser”, “roles” : [ “readWrite” ] }|&gt; db.auth(“testuser”,”testpass”)1 这样 MongoDB 的数据安全性就得到保障了，没有登录的客户端将无法执行任何命令。 修改用户密码use admindb.changeUserPassword(“username”, “xxx”) 查看用户信息db.runCommand({usersInfo:”userName”})","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"},{"name":"NOSQL","slug":"NOSQL","permalink":"http://yoursite.com/tags/NOSQL/"}]},{"title":"MongoDB第一篇 -- 基础入门","date":"2017-03-30T01:40:24.000Z","path":"2017/03/30/mongoDB/MongoDB第一篇/","text":"一、下载1、上http://dl.mongodb.org/dl/win32/x86_64 MongoDB版本网站，里面有MongoDB历史版本2、32bit的mongodb最大只能存放2G的数据，64bit就没有限制。 二、启动 1、启动之前，我们要给mongodb指定一个文件夹，这里取名为”db”,用来存放mongodb的数据。2、微软徽标+R，输入cmd，首先找到“mongodb”的路径，然后运行mongod开启命令，同时用–dbpath指定数据存放地点为“db”文件夹。3、最后要看下是否开启成功，从图中的信息中获知，mongodb采用27017端口，那么我们就在浏览器里面键入“http://localhost:27017/”，打开后，mongodb告诉我们在27017上Add 1000可以用http模式查看mongodb的管理信息。4、用同样的方式打开mongodb，如果出现lock file错误，需要进入到db文件下删除就可以开启成功。 三、基本操作 再开一个cmd，输入mongo命令打开shell，其实这个shell就是mongodb的客户端，同时也是一个js的编译器，默认连接的是“test”数据库。 insert 操作好，数据库有了，下一步就是集合，这里就取集合名为“person”，要注意的就是文档是一个json的扩展（Bson)形式。 find 操作我们将数据插入后，肯定是要find出来，不然插了也白插，这里要注意两点：“_id”： 这个字段是数据库默认给我们加的GUID，目的就是保证数据的唯一性。 update操作update方法的第一个参数为“查找的条件”，第二个参数为“更新的值”. remove操作remove中如果不带参数将删除所有数据，在mongodb中是一个不可撤回的操作。","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"},{"name":"NOSQL","slug":"NOSQL","permalink":"http://yoursite.com/tags/NOSQL/"}]},{"title":"Spring+Spring MVC+MyBatis整合","date":"2017-03-10T10:35:24.000Z","path":"2017/03/10/spring/Spring+Spring MVC+MyBatis整合/","text":"1.1设计思想 使用JSP作为展示层，spring作为控制器，用户发送请求时，使用Spring MVC找到对应的处理请求的Action，经过业务逻辑层到持久层(MyBatis)与数据库交互，最后返回给用户 1.2开发环境 操作系统：Window 7 IDE工具：Eclipse 4.4.1 服务器：Tomcat 7.0 数据库：MySQL 5.5.23 应用框架：Spring 3.2.0 +MyBatis 3.1.1 前端技术：JSP + JQuery1.7.2 1.3系统模块介绍 DAO层：由MyBatis作为DAO层，负责与数据间的交互 Sevice层：业务处理层，由Spring负责，事务管控都在此层处理， Web(Controller)层：控制层，由Spring MVC作支持，负责响应用户请求，并找到对应JSP，将结果返回给客户端 Resource层： config：主要存放配置文件，主要文件如下 applicationContext.xml Spring配置文件，数据库连接池，AOP事务控制都在此文件中配置，需要在web.xml文件中配置此文件，服务器启动时，自动加载Spring相关信息 mvc-dispatcher-servlet.xml SpringMVC配置文件，自动扫描Controller，Service，模型视图的解析都在此文件中配置，需要在web.xml文件中配置此文件，服务器启动时，自动启用Spring MVC jdbc.properties 数据库连接，用户名，密码都在此文件中配置，此文件需要在applicationContext.xml中配置 log4j.properties 日志配置文件，需要在web.xml文件中配置 1.4开发示例 applicationContext.xml < ?xml version=\"1.0\" encoding=\"UTF-8\"?> < beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd\"> < !-- 引入属性文件 --> < context:property-placeholder location=\"classpath:config/jdbc.properties\" /> < !-- 配置数据源 --> < bean name=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"> < property name=\"url\" value=\"${jdbc_url}\" /> < property name=\"username\" value=\"${jdbc_username}\" /> < property name=\"password\" value=\"${jdbc_password}\" /> < -- 初始化连接大小 --> < property name=\"initialSize\" value=\"0\" /> < !-- 连接池最大使用连接数量 --> < property name=\"maxActive\" value=\"20\" /> < !-- 连接池最大空闲 --> < property name=\"maxIdle\" value=\"20\" /> < !-- 连接池最小空闲 --> < property name=\"minIdle\" value=\"0\" /> < !-- 获取连接最大等待时间 --> < property name=\"maxWait\" value=\"60000\" /> < property name=\"validationQuery\" value=\"${validationQuery}\" /> < property name=\"testOnBorrow\" value=\"false\" /> < property name=\"testOnReturn\" value=\"false\" /> < property name=\"testWhileIdle\" value=\"true\" /> < !-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --> < property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\" /> < !-- 配置一个连接在池中最小生存的时间，单位是毫秒 --> < property name=\"minEvictableIdleTimeMillis\" value=\"25200000\" /> < !-- 打开removeAbandoned功能 --> < property name=\"removeAbandoned\" value=\"true\" /> < !-- 1800秒，也就是30分钟 --> < property name=\"removeAbandonedTimeout\" value=\"1800\" /> < !-- 关闭abanded连接时输出错误日志 --> < property name=\"logAbandoned\" value=\"true\" /> < !-- 监控数据库 --> < !-- --> < property name=\"filters\" value=\"mergeStat\" /> < /bean> < !-- myBatis文件 --> < bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"> < property name=\"dataSource\" ref=\"dataSource\" /> < !-- 自动扫描entity目录, 省掉Configuration.xml里的手工配置 --> < property name=\"mapperLocations\" value=\"classpath:mapper/*/*.xml\" /> < /bean> < bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"> < property name=\"basePackage\" value=\"com.weixin.dao\" /> < property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\" /> < /bean> < !-- 配置事务管理器 --> < bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"> < property name=\"dataSource\" ref=\"dataSource\" /> < /bean> < !-- 拦截器方式配置事物 --> < tx:advice id=\"transactionAdvice\" transaction-manager=\"transactionManager\"> < tx:attributes> < tx:method name=\"add*\" propagation=\"REQUIRED\" /> < tx:method name=\"append*\" propagation=\"REQUIRED\" /> < tx:method name=\"insert*\" propagation=\"REQUIRED\" /> < tx:method name=\"save*\" propagation=\"REQUIRED\" /> < tx:method name=\"update*\" propagation=\"REQUIRED\" /> < tx:method name=\"modify*\" propagation=\"REQUIRED\" /> < tx:method name=\"edit*\" propagation=\"REQUIRED\" /> < tx:method name=\"delete*\" propagation=\"REQUIRED\" /> < tx:method name=\"remove*\" propagation=\"REQUIRED\" /> < tx:method name=\"repair\" propagation=\"REQUIRED\" /> < tx:method name=\"delAndRepair\" propagation=\"REQUIRED\" /> < tx:method name=\"get*\" propagation=\"SUPPORTS\" /> < tx:method name=\"find*\" propagation=\"SUPPORTS\" /> < tx:method name=\"load*\" propagation=\"SUPPORTS\" /> < tx:method name=\"search*\" propagation=\"SUPPORTS\" /> < tx:method name=\"datagrid*\" propagation=\"SUPPORTS\" /> < tx:method name=\"*\" propagation=\"SUPPORTS\" /> < /tx:attributes> < /tx:advice> < aop:config> < aop:pointcut id=\"transactionPointcut\" expression=\"execution(* com.weixin.service..*Impl.*(..))\" /> < aop:advisor pointcut-ref=\"transactionPointcut\" advice-ref=\"transactionAdvice\" /> < /aop:config> < /beans> mvc-dispatcher-servlet.xml < ?xml version=\"1.0\" encoding=\"UTF-8\"?> < beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd\"> < !-- 自动扫描controller包下的所有类，使其认为spring mvc的控制器 --> < context:component-scan base-package=\"com.weixin.web.controller\" /> < context:component-scan base-package=\"com.weixin.service..*\" /> < mvc:annotation-driven /> < !-- 对模型视图名称的解析，即在模型视图名称添加前后缀 --> < bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" > < property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/> < property name=\"contentType\" value=\"text/html;charset=utf-8\"/> < property name=\"prefix\" value=\"/jsp/\"/> < property name=\"suffix\" value=\".jsp\"/> < /bean> < /beans> jdbc.properties validationQuery=SELECT 1 FROM DUAL jdbc_url=jdbc:mysql://localhost:3306/bigmouth?useUnicode=true&characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull jdbc_username=root jdbc_password=123456 log4j.properties ### set log levels ### log4j.rootLogger = debug , stdout,D ### output to the console ### log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} [%t] [%c] [%p] - %m%n ### Output to the log file ### #log4j.appender.D = org.apache.log4j.DailyRollingFileAppender #log4j.appender.D.File = D:/logs/logs.log #log4j.appender.D.File =/usr/local/java/apache-tomcat-7.0.62/logs/logs.log #log4j.appender.D.Append = true #log4j.appender.D.Threshold = INFO #log4j.appender.D.datePattern='.'yyyy-MM-dd #log4j.appender.D.layout = org.apache.log4j.PatternLayout #log4j.appender.D.layout.ConversionPattern = %d{yyyy-MM-dd HH:mm:ss} [%t] [%c] [%p] - %m%n 1.在/com/weixin/model/user/目录下创建User对象，代码如下 package com.weixin.model.user; public class User { private StringuserId; private StringuserName; private Stringpassword; public String getUserId() { return userId; } public void setUserId(String userId) { this.userId =userId; } public String getUserName() { returnuserName; } public void setUserName(String userName) { this.userName =userName; } public String getPassword() { return password; } public void setPassword(String password) { this.password =password; } } 2.在/resource/mapper/user/目录下创建操作用户的配置文件UserMapper.xml，此文件属于MyBatis操作数据库的文件，用户的增删改查SQl都在此文件中配置，内容如下 < ?xmlversion=\"1.0\"encoding=\"UTF-8\"?> < !DOCTYPEmapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> < mappernamespace=\"com.weixin.dao.user.IUserDao\"> < resultMapid=\"user\"type=\"com.weixin.model.user.User\"> < resultcolumn=\"user_id\"property=\"userId\"jdbcType=\"VARCHAR\"/> < resultcolumn=\"user_name\"property=\"userName\"jdbcType=\"VARCHAR\"/> < resultcolumn=\"password\"property=\"password\"jdbcType=\"VARCHAR\"/> < /resultMap> < selectid=\"selectUserNameById\"parameterType=\"Integer\" resultType=\"String\"> SELECT t.user_name FROM user_t t WHERE t.user_id = #{userId} < /select> < selectid=\"selectAllUser\"resultMap=\"user\"> SELECT t.user_name,t.password FROM user_t t < /select> < updateid=\"updateUser\"parameterType=\"com.weixin.model.user.User\"> update user_t t set t.user_name = #{userName} where t.user_id = #{userId} < /update> < insertid=\"addUser\"parameterType=\"com.weixin.model.user.User\" useGeneratedKeys=\"true\"keyProperty=\"userId\"> insert into user_t(user_name,password) values(#{userName},#{password}) < /insert> < deleteid=\"deleteUserByUserId\"parameterType=\"Integer\"> delete from user_t where user_id = #{userId} < /delete> < /mapper> 注意：需要指定namespace，value值是对应DAO文件的全限定名 3.在/com/weixin/dao/user/目录下创建IUserDao.Java文件，此文件提供对用户增删改查的对应接口，接口名必须与UserMapper.xml文件中的id值一一对应，内容如下 package com.weixin.dao.user; import java.util.List; import com.weixin.model.user.User; public interface IUserDao { String selectUserNameById(int userId); List selectAllUser(); void updateUser(User user); void addUser(User user); void deleteUserByUserId(int userId); } 不需要为IUserDao接口提供对应的实现，MyBatis会根据接口名，及UserMapper.xml文件中的namespace,找到对应的SQL，并执行 4.提供Service层接口，在/com/weixin/service/user/路径下创建IUserService.java文件，代码如下 package com.weixin.service.user; import java.util.List;import com.weixin.model.user.User; public interface IUserService { public String selectUserNameById(int userId); public List&lt;User&gt; selectAllUser(); void updateUser(User user); void addUser(User user); void deleteUserByUserId(int userId); }5.提供IUserService的实现UserServiceImpl，在/com/weixin/service/user/路径下创建UserServiceImpl.java文件，代码如下 package com.weixin.service.user; import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.weixin.dao.user.IUserDao;import com.weixin.model.user.User; @Service(“userService”)public class UserServiceImpl implements IUserService { IUserDao userDao; @Autowired public void setUserDao(IUserDao userDao) { this.userDao = userDao; } @Override public String selectUserNameById(int userId) { return userDao.selectUserNameById(userId); } @Override public List&lt;User&gt; selectAllUser() { return userDao.selectAllUser(); } @Override public void updateUser(User user) { userDao.updateUser(user); } @Override public void addUser(User user) { userDao.addUser(user); } @Override public void deleteUserByUserId(int userId) { userDao.deleteUserByUserId(userId); } }说明： 需要为UserServiceImpl指定@Service(“userService”)，说明该Service具有业务处理的功能，Controller层中会使用userService调用对应的业务接口 在setUserDao()文件中使用@Autowired，Spring会根据此标识自动装载userDao 6.在/com/weixin/web/controller/user/路径下创建UserController.java，负责响应用户的请求，代码如下 package com.weixin.web.controller.user; import java.util.List;import javax.servlet.http.HttpServletRequest;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import com.weixin.model.user.User;import com.weixin.service.user.IUserService; @Controller@RequestMapping(“user”)public class UserController { private static Log log = LogFactory.getLog(UserController.class); IUserService userService; @RequestMapping(&quot;index&quot;) public String index(HttpServletRequest request) { String userName = userService.selectUserNameById(1); System.out.println(userName); log.info(&quot;select username success&quot;); /*User user = new User(); user.setUserId(&quot;1&quot;); user.setUserName(&quot;spring&quot;); userService.updateUser(user);*/ /*User user = new User(); user.setUserName(&quot;aaa&quot;); user.setPassword(&quot;123456&quot;); userService.addUser(user);*/ /*int userId = 7; userService.deleteUserByUserId(userId);*/ List&lt;User&gt; userList = userService.selectAllUser(); request.setAttribute(&quot;userList&quot;, userList); return &quot;index&quot;; } @Autowired public void setUserService(IUserService userService) { this.userService = userService; } }说明： 使用@Controller，使UserController既有控制器的功能 在UserController上使用@RequestMapping，指定该控制器的访问根路径；在方法上使用@RequestMapping，指定使用哪个方法接收用户请求 在setUserService(IUserServiceuserService)方法中使用@Autowired，Spring会根据此标识自动装载userService 7.在/WebContent/jsp/路径下创建index.jsp，代码如下 &lt; %@ include file=”/jsp/common/common.jsp”%&gt;&lt; !DOCTYPEhtml PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” “http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt; html&gt;&lt; head&gt;&lt; metahttp-equiv=”Content-Type”content=”text/html; charset=utf-8”&gt;&lt; title&gt;Insert title here&lt; /head&gt;&lt; body&gt;&lt; c:forEachvar=”u”items=”${userList }”&gt; ${u.userName }&lt; /c:forEach&gt;&lt; /body&gt;&lt; /html&gt;8.修改web.xml文件内容，修改后内容如下 &lt; ?xmlversion=”1.0”encoding=”UTF-8”?&gt;&lt; web-appversion=”3.0” xmlns=”http://java.sun.com/xml/ns/javaee“ xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance“ xsi:schemaLocation=”http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;&gt; &lt; display-name&gt;spring_mybatis&lt; /display-name&gt; &lt; context-param&gt; &lt; param-name&gt;contextConfigLocation&lt; /param-name&gt; &lt; param-value&gt;classpath:config/applicationContext.xml&lt; /param-value&gt; &lt; /context-param&gt; &lt; context-param&gt; &lt; !– 日志配置文件路径 –&gt; &lt; param-name&gt;log4jConfigLocation&lt; /param-name&gt; &lt; param-value&gt;classpath:config/log4j.properties&lt; /param-value&gt; &lt; /context-param&gt; &lt; context-param&gt; &lt; !– 日志页面的刷新间隔 –&gt; &lt; param-name&gt;log4jRefreshInterval &lt; param-value&gt;6000 &lt; /context-param&gt; &lt; listener&gt; &lt; listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt; /listener-class&gt; &lt; /listener&gt; &lt; listener&gt; &lt; listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt; /listener-class&gt; &lt; /listener&gt; &lt; listener&gt; &lt; listener-class&gt;org.springframework.web.context.ContextCleanupListener&lt; /listener-class&gt; &lt; servlet&gt; &lt; servlet-name&gt;mvc-dispatcher&lt; /servlet-name&gt; &lt; servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt; /servlet-class&gt; &lt; init-param&gt; &lt; param-name&gt;contextConfigLocation&lt; /param-name&gt; &lt; param-value&gt;classpath:config/mvc-dispatcher-servlet.xml&lt; /param-value&gt; &lt; /init-param&gt; &lt; load-on-startup&gt;1&lt; /load-on-startup&gt; &lt; /servlet&gt; &lt; servlet-mapping&gt; &lt; servlet-name&gt;mvc-dispatcher&lt; /servlet-name&gt; &lt; url-pattern&gt;*.do&lt; /url-pattern&gt; &lt; /servlet-mapping&gt;&lt; /web-app&gt;启动服务器，在浏览器中输入如下URL发送请求，请求成功 http://localhost:8080/spring_mybatis/user/index.do","tags":[{"name":"springMVC","slug":"springMVC","permalink":"http://yoursite.com/tags/springMVC/"},{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"},{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"使用JQuery获取对象的几种方式","date":"2017-03-10T07:35:24.000Z","path":"2017/03/10/JQuery/使用JQuery获取对象的几种方式/","text":"1、先讲讲JQuery的概念JQuery首先是由一个 America 的叫什么 John Resig的人创建的，后来又很多的JS高手也加入了这个团队。其实 JQuery是一个JavaScript的类库，这个类库集合了很多功能方法，利用类库你可以用简单的一些代码实现一些复杂的JS效果。2、JQuery实现了 代码的分离不用再网页中加入如：onclick之类的事件来调用函数了，直接引入JQuery类库和自己编写的JQuery代码就可以了； JQuery代码 $(function(){ $(“Element”).click{function(){ alert(“点击我哦！”); } }})；上面的代码中 只要定义了Element 这个元素后面的click是动作alert(“点击我哦！”);这个是要执行的代码，当然你可以有很多的操作在这个函数中；这里面的$这个号代表JQuery的意思 ，就是引用类库了。。。我是这么理解的； 3、JQuery的核心的一些方法 each(callback) ‘就像循环 $(“Element”).length; ‘元素的个数，是个属性 $(“Element”).size(); ’也是元素的个数，不过带括号是个方法 $(“Element”).get(); ‘某个元素在页面中的集合，以数组的形式存储 $(“Element”).get(index); ’功能和上面的相同，index表示第几个元素，数组的下标 $(“Element”).get().reverse(); ‘把得到的数组方向 $(“Element1”).index($(“Element2”)); ’元素2在元素1中的索引值是。。。 4、基本对象获取(注意这里获取的都是Jquery对象而不是Dom对象哦，但是他俩是可以转换滴) $(“*”) ‘表示获取所有对象 但是我至今没这样用过 $(“#XXX”) ’获得 id=XXX 的元素对象（id可以是标签的id或CSS样式id） 常用 $(“input[name=’username’]”) 获得input标签中name=’userName’的元素对象 常用 $(“.abc”) ‘ 获得样式class的名字是.abc的元素对象 常用 $(“div”) ‘ 标签选择器 选择所有的div元素 常用 $(“#a,.b,span”) ‘表示获得ID是a的元素和使用了类样式b的元素以及所有的span元素 $(“#a .b p”) ‘ID号是a的并且使用了 b样式的 所有的p元素 5、层级元素获取 $(“Element1 Element2 Element3 ….”) ‘前面父级 后面是子集 $(“div &gt; p”) ‘获取div下面的所有的 p元素 $(“div + p”) ‘div元素后面的第一个 p元素 $(“div ~ p”) ‘div后面的所有的 p元素 6、简单对象获取 $(“Element:first”) ‘HTML页面中某类元素的第一个元素 $(“Element:last”) ‘HTML页面中某类元素的最后一个元素 $(“Element:not(selector)”) ‘去除所有与给定选择器匹配的元素,如：$(“input:not(:checked)”) 表示选择所有没有选中的复选框 $(“Element:even”) ‘获得偶数行 $(“Element:odd“）’获得奇数行 $(“Element:eq(index)”) ‘取得一个给定的索引值 $(“Element:gt(index)”) ‘取得给定索引值的元素 之后的所有元素 $(“Element:lt(index)”) ‘取得给定索引值的元素 之前的所有元素。。。 7、内容对象的获取和对象可见性 $(“Element:contains(text)”) ‘元素中是否包含text文本内容 $(‘Element:empty”) ‘获得元素不包含子元素或文本的 $(“Element:partnt”) ‘获得元素包含子元素或文本的 $(“Element:has(selector)”) ‘是否包含某个元素， 如：$(“p:has(span)”)表示所有包含span元素的p元素 $(“Element:hidden”) ‘选择所有可见元素 $(“Element:visible”) ‘选择所有不可见元素 8、其他对象获取方法 $(“Element[id]”) ‘所有带有ID属性的元素 $(“Element[attribute = youlika ]” ‘获得所有某个属性为youlika的元素 $(“Element[attribute != youlika ]” ‘获得所有某个属性为不是youlika的元素 $(“Element[attribute ^= youlika ]” ‘获得所有某个属性为不是youlika的开头的元素 $(“Element[attribute $= youlika ]” ‘获得所有某个属性为不是youlika的结尾的元素 $(“Element[attribute *= youlika ]” ‘获得所有某个属性包含youlika的开头的元素 $(“Element[selector1][selector2][….]”) ’符合属性选择器，比如$(“input[id][name][value=youlika ]”)表示获得带有ID、Name以及value是youlika 的input元素。 9、子元素的获取 $(“Element:nth-child(index)”) ‘选择父级下面的第n个元素 $(“Element:nth-child(even)”) ‘选择父级下面的偶数 $(“Element:nth-child(odd)”) ‘选择父级下面的奇数 $(“Element:nth-child(3n+1)”) ‘表达式 $(“Element:first-child”) ‘选择父级下面的第一个子元素 $(“Element:last-child”) ‘选择父级下面的最后一个子元素 $(“Element:only-child”) ‘匹配父级下的唯一的一个子级元素，例如dt在dl列表中唯一，那么将选择dt 10、表单对象获取 $(:input)//查找所有的Input元素，当然也包括下拉列表，文本域，单选框，复选框等。 $(:text)//匹配所有的单行文本框 $(:password)//匹配所有的密码框 $(:radio)//匹配所有的单选按钮 $(:checkbox)//匹配所有的复选框 $(:submit)//匹配所有的提交按钮 $(:image)//匹配所有的图像域，例如 &lt; input type=”image” /&gt; $(:reset)//匹配所有的重置按钮 $(:button)//匹配所有的按钮 $(:file)//匹配所有的文件上传域 $(:hidden)//匹配所有的不可见元素或者type为hidden的元素 $(:enabled)//匹配所有可用的input元素，比如radio:enabled表示匹配所有可用的单选按钮 $(:disabled)//匹配所有的不可用input元素，作用与上相反 $(:checked)//匹配所有选中的复选框元素 $(:selected)//匹配所有的下拉列表 11、元素属性的设置与移除 $(“Element”).attr(name) ‘取得第一个匹配的属性值，比如$(“img”).attr(“src”) $(“Element”.attr(key,value)”) ‘某一个元素设置属性 $(“Element”.attr({key:value,key1:value,….})) ‘为某个元素一次性设置多个属性 $(“Element”).attr(key,function) ‘为所有匹配的元素设置一个计算的属性值。 $(“Element”).removeAttr(name)//移除某一个属性","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"},{"name":"web前端","slug":"web前端","permalink":"http://yoursite.com/tags/web前端/"}]},{"title":"elasticsearch更改mapping，不停服务重建索引","date":"2017-03-10T07:35:24.000Z","path":"2017/03/10/elasticsearch/elasticsearch更改mapping，不停服务重建索引/","text":"Elasticsearch的mapping一旦创建，只能增加字段，而不能修改已经mapping的字段。但现实往往并非如此啊，有时增加一个字段，就好像打了一个补丁，一个可以，但是越补越多，最后自己都觉得惨不忍睹了。怎么办？？这里有一个方法修改mapping，那就是重新建立一个index，然后创建一个新的mapping。你可能会问，这要是在生产环境，可行吗？答案是，如果你一开始就采取了合适的设计，这个完全是可以做到平滑过渡的。 采取什么合理设计呢？就是我们的程序访问索引库时，始终使用同义词来访问，而不要使用真正的indexName。在reindex完数据之后，修改之前的同义词即可。 step1、创建一个索引，这个索引的名称最好带上版本号，比如my_index_v1,my_index_v2等。 step2、创建一个指向本索引的同义词。 ES代码 curl -XPOST localhost:9200/_aliases -d ' { \"actions\": [ { \"add\": { \"alias\": \"my_index\", \"index\": \"my_index_v1\" }} ] } 此时，你可以通过同义词my_index访问。包括创建索引，删除索引等。 step3，需求来了，需要更改mapping了，此时，你需要创建一个新的索引，比如名称叫my_index_v2（版本升级）.，在这个索引里面创建你新的mapping结构。然后，将新的数据刷入新的index里面。在刷数据的过程中，你可能想到直接从老的index中取出数据，然后更改一下格式即可。如何遍历所有的老的index数据，请参考这里。 step4，修改同义词。将指向v1的同义词，修改为指向v2。ES代码 curl -XPOST localhost:9200/_aliases -d ' { \"actions\": [ { \"remove\": { \"alias\": \"my_index\", \"index\": \"my_index_v1\" }}, { \"add\": { \"alias\": \"my_index\", \"index\": \"my_index_v2\" }} ] } step5，删除老的索引。 ES代码 curl -XDELETE localhost:9200/my_index_v1 除此之外，还有几个其他的方法也可以更改mapping。 1、修改程序，添加字段。 就是说，你可以在mapping中增加一个新的字段，然后你对新的字段进行访问统计搜索。这个就要修改两个地方，一个是修改mapping增加字段，还有就是修改你的程序，把字段改成新的字段。 2、更改字段类型为multi_field。 multi_field允许为一个字段设置多个数据类型。应用multi_field的一个最典型的场景是：一个类型定义为analyed，这个字段可以被搜索到，一个类型定义为不分词，这个字段用于排序。 任何字段都可以被更新为multi_field（类型为object和nested的类型除外）。假设现在有一个字段，名字叫created，类型现在为string。 ES代码 { \"created\": { \"type\": \"string\"} } 我们可以将它增加一种类型，使他既能被当做字符串又能当做日期型。 ES代码 curl -XPUT localhost:9200/my_index/my_type/_mapping -d ' { \"my_type\": { \"properties\": { \"created\": { \"type\": \"multi_field\", \"fields\": { \"created\": { \"type\": \"string\" }, \"date\": { \"type\": \"date\" } } } } } } 采用标准的重建索引方式的时候，我们推荐大家为每一个type都建立一个索引同义词，即便在同一个索引库中的多个type，也推荐使用建立一个同义词来访问。即一个index里面包含一个type，因为在elasticsearch中，跨index查询数据是很方便的。这样，我们就可以在reindex一个type后，立即将type生效，而不是将index下面所有的type都重建完后，同义词才能生效。","tags":[{"name":"ES","slug":"ES","permalink":"http://yoursite.com/tags/ES/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://yoursite.com/tags/elasticsearch/"}]},{"title":"MySQL单列索引和组合索引的区别介绍","date":"2017-03-10T07:35:24.000Z","path":"2017/03/10/mysql/MySQL单列索引和组合索引的区别介绍/","text":"MySQL单列索引是我们使用MySQL数据库中经常会见到的，MySQL单列索引和组合索引的区别可能有很多人还不是十分的了解，下面就为您分析两者的主要区别，供您参考学习。 为了形象地对比两者，再建一个表： mysql代码 CREATE TABLE myIndex ( i_testID INT NOT NULL AUTO_INCREMENT, vc_Name VARCHAR(50) NOT NULL, vc_City VARCHAR(50) NOT NULL, i_Age INT NOT NULL, i_SchoolID INT NOT NULL, PRIMARY KEY (i_testID) ); 在这 10000 条记录里面有5 条 vc_Name=”erquan” 的记录，只不过 city,age,school 的组合各不相同。来看这条T-SQL： mysql代码 SELECT i_testID FROM myIndex WHERE vc_Name='erquan' AND vc_City='郑州' AND i_Age=25; 首先考虑建MySQL单列索引： 在vc_Name列上建立了索引。执行 T-SQL 时，MYSQL 很快将目标锁定在了vc_Name=erquan 的 5 条记录上，取出来放到一中间结果集。在这个结果集里，先排除掉 vc_City 不等于”郑州”的记录，再排除 i_Age 不等于 25 的记录，最后筛选出唯一的符合条件的记录。 虽然在 vc_Name 上建立了索引，查询时MYSQL不用扫描整张表，效率有所提高，但离我们的要求还有一定的距离。同样的，在 vc_City 和 i_Age 分别建立的MySQL单列索引的效率相似。 为了进一步榨取 MySQL 的效率，就要考虑建立组合索引。就是将 vc_Name,vc_City，i_Age 建到一个索引里： mysql代码 ALTER TABLE myIndex ADD INDEX name_city_age (vc_Name(10),vc_City,i_Age); 建表时，vc_Name 长度为 50，这里为什么用 10 呢？因为一般情况下名字的长度不会超过 10，这样会加速索引查询速度，还会减少索引文件的大小，提高 INSERT 的更新速度。 执行 T-SQL 时，MySQL 无须扫描任何记录就到找到唯一的记录。 肯定有人要问了，如果分别在 vc_Name,vc_City，i_Age 上建立单列索引，让该表有 3 个单列索引，查询时和上述的组合索引效率一样吗？大不一样，远远低于我们的组合索引。虽然此时有了三个索引，但 MySQL 只能用到其中的那个它认为似乎是最有效率的单列索引。 建立这样的组合索引，其实是相当于分别建立了 mysql代码 1. vc_Name,vc_City,i_Age 2. vc_Name,vc_City 3. vc_Name 这样的三个组合索引！为什么没有 vc_City，i_Age 等这样的组合索引呢？这是因为 mysql 组合索引“最左前缀”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引，下面的几个 T-SQL 会用到： mysql代码 SELECT * FROM myIndex WHREE vc_Name=\"erquan\" AND vc_City=\"郑州\" SELECT * FROM myIndex WHREE vc_Name=\"erquan\" 而下面几个则不会用到： SELECT * FROM myIndex WHREE i_Age=20 AND vc_City=\"郑州\" SELECT * FROM myIndex WHREE vc_City=\"郑州\"","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"Java中List 去掉重复的值，并保持原先List顺序","date":"2017-02-24T10:35:24.000Z","path":"2017/02/24/java/Java中List 去掉重复的值，并保持原先List顺序/","text":"Java 代码： private List removeDuplicate(List list) { Set set = new HashSet(); List newList = new ArrayList(); for (Iterator iter = list.iterator(); iter.hasNext();) { YourBean element = (YourBean) iter.next(); if (set.add(element)) newList.add(element); } return newList; }","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Tomcat配置去掉项目名称，直接通过域名访问","date":"2017-02-24T10:35:24.000Z","path":"2017/02/24/Tomcat/Tomcat配置去掉项目名称，直接通过域名访问/","text":"项目开发过程中，一般的项目访问的方式是：http://ip:端口号/projectName，项目上线后，往往只需要输入域名就可以访问项目，在URL中过滤掉了项目名称，Tomcat中如何实现如上配置呢1、修改端口号为80将conf目录下的server.xml文件中的 &lt; Connector port=”8080” protocol=”HTTP/1.1” connectionTimeout=”20000” redirectPort=”8443” /&gt;改为 &lt; Connector port=”80” protocol=”HTTP/1.1” connectionTimeout=”20000” redirectPort=”8443” /&gt;2、去除项目名称projectName在server.xml文件中，修改标签，在标签中增加， 修改后如 &lt; Host name=”localhost” appBase=”webapps” unpackWARs=”true” autoDeploy=”true”&gt;&lt; Context docBase=”F:\\all_workspace\\workspace_wixin\\bigmouth_crm\\WebContent” path=”” /&gt;&lt; /Host&gt;3、重启Tomcat，URL地址样中输入http://ip，就可以访问你的项目了","tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://yoursite.com/tags/tomcat/"}]},{"title":"java foreach遍历的前提条件","date":"2017-02-24T10:35:24.000Z","path":"2017/02/24/java/java foreach遍历的前提条件/","text":"目的： 加深foreach遍历的影响证明：foreach遍历的前提条件是：list !=null ,而不是：list !=null &amp;&amp; list.size() &gt;0 说明： jdk -version : 1.7 Java代码 public static void main(String[] args) { List list = null; // List list = new ArrayList(); for(String temp : list){ System.out.println(temp); } System.out.println(“over”);}现象：当list为null时，走到foreach语句时，会报空指针异常 当list =new ArrayList 时，未报任何异常 总结：list.size() &gt; 0不是foreach的必要前提条件，而list != null才是foreach的前提条件","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Windows下安装ELK","date":"2017-02-24T10:35:24.000Z","path":"2017/02/24/elasticsearch/Windows下安装ELK/","text":"安装java JDK 下载jdk，http://download.oracle.com/otn-pub/java/jdk/8u65-b17/jdk-8u65-windows-x64.exe安装即可 配置JDK环境变量 右键我的电脑属性高级系统设置高级环境变量。在用户变量中新建Java_Home(如果已经存在，则忽略)，输入值为 jdk的安装目录 比如 C:\\Program Files\\Java\\jdk1.8.0_65(注意是32位还是64位，根据系统的版本确定)。在用户变量中新建 CLASSPATH (如果存在，则编辑)，输入%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar(如果存在，则忽略，注意字符前的 ; 符号)在系统变量中找到Path变量，进行编辑。在最后加上 %JAVA_HOME%\\bin (注意，如果已经存在，则忽略。另外，注意在字符前需要有 ; 符号，如果已经存在则忽略) 安装Elasticsearch 下载最新版的Elasticsearchhttps://www.elastic.co/downloads/elasticsearch解压安装包之后，执行 bin\\elasticsearch.bat打开 http://localhost:9200 测试是否安装成功 安装head插件 使用cmd命令： cd \\elasticsearch根目录\\bin\\在当前目录中执行 plugin install mobz/elasticsearch-head 命令 运行es服务，打开http://localhost:9200/_plugin/head/ 如过在线安装失败，可使用手动安装包 https://github.com/mobz/elasticsearch-head 运行安装命令：plugin install file:/path/to/my-plugin-1.2.1.zip 配置详解 下载完解开有三个包:bin是运行的脚本，config是设置文件，lib是放依赖的包。如果你要装插件的话就要多新建一个plugins的文件夹，把插件放到这个文件夹中。 elasticsearch的config文件夹里面有两个配置文 件：elasticsearch.yml和logging.yml，第一个是es的基本配置文件，第二个是日志配置文件，es也是使用log4j来记录日 志的，所以logging.yml里的设置按普通log4j配置文件来设置就行了。下面主要讲解下elasticsearch.yml这个文件中可配置的东西。 cluster.name: elasticsearch 配置es的集群名称，默认是elasticsearch，es会自动发现在同一网段下的es，如果在同一网段下有多个集群，就可以用这个属性来区分不同的集群。 node.name: “Franz Kafka” 节点名，默认随机指定一个name列表中名字，该列表在es的jar包中config文件夹里name.txt文件中 node.master: true 指定该节点是否有资格被选举成为node，默认是true，es是默认集群中的第一台机器为master，如果这台机挂了就会重新选举master。 node.data: true 指定该节点是否存储索引数据，默认为true。如果节点配置node.master:false并且node.data: false，则该节点将起到负载均衡的作用 index.number_of_shards: 5 设置默认索引分片个数，默认为5片。经本人测试，索引分片对ES的查询性能有很大的影响，在应用环境，应该选择适合的分片大小。 index.number_of_replicas: 1 设置默认索引副本个数，默认为1个副本。此处的1个副本是指index.number_of_shards的一个完全拷贝；默认5个分片1个拷贝；即总分片数为10。 path.conf: /path/to/conf 设置配置文件的存储路径，默认是es根目录下的config文件夹。 path.data: /path/to/data 设置索引数据的存储路径，默认是es根目录下的data文件夹，可以设置多个存储路径，用逗号隔开，例：path.data: /path/to/data1,/path/to/data2 path.work: /path/to/work 设置临时文件的存储路径，默认是es根目录下的work文件夹。 path.logs: /path/to/logs 设置日志文件的存储路径，默认是es根目录下的logs文件夹 path.plugins: /path/to/plugins 设置插件的存放路径，默认是es根目录下的plugins文件夹 bootstrap.mlockall: true 设置为true来锁住内存。因为当jvm开始swapping时es的效率会降低，所以要保证它不swap，可以把ES_MIN_MEM和 ES_MAX_MEM两个环境变量设置成同一个值，并且保证机器有足够的内存分配给es。同时也要允许elasticsearch的进程可以锁住内 存，linux下可以通过ulimit -l unlimited命令。 network.bind_host: 192.168.0.1 设置绑定的ip地址，可以是ipv4或ipv6的，默认为0.0.0.0。 network.publish_host: 192.168.0.1 设置其它节点和该节点交互的ip地址，如果不设置它会自动判断，值必须是个真实的ip地址。 network.host: 192.168.0.1 这个参数是用来同时设置bind_host和publish_host上面两个参数。 transport.tcp.port: 9300 设置节点间交互的tcp端口，默认是9300。 transport.tcp.compress: true 设置是否压缩tcp传输时的数据，默认为false，不压缩。 http.port: 9200 设置对外服务的http端口，默认为9200。 http.max_content_length: 100mb 设置内容的最大容量，默认100mb http.enabled: false 是否使用http协议对外提供服务，默认为true，开启。 gateway.type: local gateway的类型，默认为local即为本地文件系统，可以设置为本地文件系统，分布式文件系统，hadoop的HDFS，和amazon的s3服务器,等方式 gateway.recover_after_nodes: 1 设置集群中N个节点启动时进行数据恢复，默认为1。 gateway.recover_after_time: 5m 设置初始化数据恢复进程的超时时间，默认是5分钟。 gateway.expected_nodes: 2 设置这个集群中节点的数量，默认为2，一旦这N个节点启动，就会立即进行数据恢复。 cluster.routing.allocation.node_initial_primaries_recoveries: 4 初始化数据恢复时，并发恢复线程的个数，默认为4。 cluster.routing.allocation.node_concurrent_recoveries: 2 添加删除节点或负载均衡时并发恢复线程的个数，默认为4。 indices.recovery.max_size_per_sec: 0 设置数据恢复时限制的带宽，如入100mb，默认为0，即无限制。 indices.recovery.concurrent_streams: 5 设置这个参数来限制从其它分片恢复数据时最大同时打开并发流的个数，默认为5。 discovery.zen.minimum_master_nodes: 1 设置这个参数来保证集群中的节点可以知道其它N个有master资格的节点。默认为1，对于大的集群来说，可以设置大一点的值（2-4） discovery.zen.ping.timeout: 3s 设置集群中自动发现其它节点时ping连接超时时间，默认为3秒，对于比较差的网络环境可以高点的值来防止自动发现时出错。 discovery.zen.ping.multicast.enabled: false 设置是否打开多播发现节点，默认是true。 discovery.zen.ping.unicast.hosts: [“host1”, “host2:port”, “host3[portX-portY]”] 设置集群中master节点的初始列表，可以通过这些节点来自动发现新加入集群的节点。 threadpool: search: type: fixed min: 60 max: 80 queue_size: 1000配置es服务器的执行查询操作时所用线程池，fix固定线程数的线程池。 index : store: type: memory 表示索引存储在内存中，当然es不太建议这么做。经本人测试，做查询时，使用内存索引并不会比正常的索引快。 index.mapper.dynamic: false 禁止自动创建mapping。默认情况下，es可以根据数据类型自动创建mapping。配置成这样，可以禁止自动创建mapping的行为 index.query.parse.allow_unmapped_fields: false 不能查找没有在mapping中定义的属性 下面是一些查询时的慢日志参数设置 index.search.slowlog.level: TRACE index.search.slowlog.threshold.query.warn: 10s index.search.slowlog.threshold.query.info: 5s index.search.slowlog.threshold.query.debug: 2s index.search.slowlog.threshold.query.trace: 500ms index.search.slowlog.threshold.fetch.warn: 1s index.search.slowlog.threshold.fetch.info: 800ms index.search.slowlog.threshold.fetch.debug:500ms index.search.slowlog.threshold.fetch.trace: 200ms","tags":[{"name":"ES","slug":"ES","permalink":"http://yoursite.com/tags/ES/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://yoursite.com/tags/elasticsearch/"}]},{"title":"SpringMVC @RequestBody接收Json对象字符串","date":"2017-02-24T10:35:24.000Z","path":"2017/02/24/spring/SpringMVC @RequestBody接收Json对象字符串/","text":"以前，一直以为在SpringMVC环境中，@RequestBody接收的是一个Json对象，一直在调试代码都没有成功，后来发现，其实 @RequestBody接收的是一个Json对象的字符串，而不是一个Json对象。然而在ajax请求往往传的都是Json对象，后来发现用 JSON.stringify(data)的方式就能将对象变成字符串。同时ajax请求的时候也要指定dataType: “json”,contentType:”application/json” 这样就可以轻易的将一个对象或者List传到Java端，使用@RequestBody即可绑定对象或者List.JavaScript 代码： $(document).ready(function(){ var saveDataAry=[]; var data1={\"userName\":\"test\",\"address\":\"gz\"}; var data2={\"userName\":\"ququ\",\"address\":\"gr\"}; saveDataAry.push(data1); saveDataAry.push(data2); $.ajax({ type:\"POST\", url:\"user/saveUser\", dataType:\"json\", contentType:\"application/json\", data:JSON.stringify(saveData), success:function(data){ } }); }); Java代码 @RequestMapping(value = \"saveUser\", method = {RequestMethod.POST }}) @ResponseBody public void saveUser(@RequestBody List users) { userService.batchSave(users); }","tags":[{"name":"springMVC","slug":"springMVC","permalink":"http://yoursite.com/tags/springMVC/"}]},{"title":"mybatis中#跟$的区别","date":"2017-02-24T10:35:24.000Z","path":"2017/02/24/spring/mybatis/","text":"1.#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by “111”, 如果传入的值是id，则解析成的sql为order by “id”.2.$将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111,那么解析成sql时的值为order by user_id, 如果传入的值是id，则解析成的sql为order by id. 3.#方式能够很大程度防止sql注入,$方式无法防止Sql注入。 4.$方式一般用于传入数据库对象，例如传入表名.一般能用#的就别用$. 5.MyBatis排序时使用order by 动态参数时需要注意，用$而不是#","tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]}]